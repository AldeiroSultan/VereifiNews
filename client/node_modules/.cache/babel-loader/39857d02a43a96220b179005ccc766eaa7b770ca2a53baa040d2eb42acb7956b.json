{"ast":null,"code":"/**\r\n * Client-side implementation of text summarization and credibility analysis\r\n */\n\n/**\r\n * Process article text and provide summary and credibility analysis\r\n * @param {string} text - Article text\r\n * @returns {Object} - Result containing summary and credibility analysis\r\n */\nexport const processArticleClientSide = text => {\n  // 1. Summarization\n  const summary = summarizeText(text);\n\n  // 2. Credibility analysis\n  const credibilityAnalysis = analyzeCredibility(text);\n  return {\n    summary,\n    credibilityScore: credibilityAnalysis.score,\n    credibilityFactors: credibilityAnalysis.factors\n  };\n};\n\n/**\r\n * Text summarization algorithm (extractive approach)\r\n * @param {string} text - Text to summarize\r\n * @returns {string} - Summarized text\r\n */\nexport const summarizeText = text => {\n  // Split text into sentences\n  const sentences = text.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0);\n  if (sentences.length === 0) {\n    return \"Unable to summarize. Please provide more content.\";\n  }\n\n  // Calculate word frequency (simple TF)\n  const wordFreq = {};\n  const stopWords = new Set(['a', 'an', 'the', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'in', 'on', 'at', 'to', 'for', 'with', 'by', 'about', 'as', 'of', 'that', 'this', 'these', 'those', 'it', 'its', 'they', 'them', 'their', 'there', 'here', 'where', 'when', 'how', 'has', 'have', 'had', 'not', 'no', 'nor', 'if', 'else', 'then', 'so', 'than', 'up', 'down', 'out', 'off', 'over', 'under']);\n  sentences.forEach(sentence => {\n    // Tokenize and clean\n    const words = sentence.toLowerCase().split(/\\W+/).filter(word => word.length > 1 && !stopWords.has(word));\n\n    // Count word frequency\n    words.forEach(word => {\n      wordFreq[word] = (wordFreq[word] || 0) + 1;\n    });\n  });\n\n  // Score sentences based on word frequency\n  const sentenceScores = sentences.map(sentence => {\n    const words = sentence.toLowerCase().split(/\\W+/).filter(word => word.length > 1);\n    let score = 0;\n    words.forEach(word => {\n      if (wordFreq[word]) {\n        score += wordFreq[word];\n      }\n    });\n\n    // Normalize by sentence length (with a minimum to avoid division by zero)\n    return {\n      text: sentence.trim(),\n      score: score / Math.max(words.length, 1)\n    };\n  });\n\n  // Sort sentences by score (descending)\n  sentenceScores.sort((a, b) => b.score - a.score);\n\n  // Select top sentences (about 25% of the original length, minimum 3, maximum 7)\n  const numSentences = Math.min(Math.max(Math.ceil(sentences.length * 0.25), 3), 7);\n\n  // Get top sentences\n  const topSentences = sentenceScores.slice(0, numSentences);\n\n  // Map to original indices\n  const topIndices = topSentences.map(s => {\n    return sentences.findIndex(sentence => sentence.trim() === s.text);\n  });\n\n  // Sort by original order\n  topIndices.sort((a, b) => a - b);\n\n  // Join the selected sentences in their original order\n  const summarySentences = topIndices.map(index => sentences[index].trim());\n  let result = summarySentences.join('. ');\n\n  // Ensure proper ending punctuation\n  if (!result.endsWith('.') && !result.endsWith('!') && !result.endsWith('?')) {\n    result += '.';\n  }\n  return result;\n};\n\n/**\r\n * Credibility analysis algorithm\r\n * @param {string} text - Text to analyze\r\n * @returns {Object} - Credibility score and factors\r\n */\nexport const analyzeCredibility = text => {\n  // This is a simplified version that checks for common markers of credibility\n  const factors = [];\n  let score = 50; // Start with a neutral score\n\n  // Normalize text for analysis\n  const normalizedText = text.toLowerCase();\n\n  // 1. Check text length (longer articles tend to have more depth)\n  if (text.length > 3000) {\n    score += 5;\n    factors.push({\n      type: 'positive',\n      text: 'Article length indicates depth of coverage'\n    });\n  } else if (text.length < 1000) {\n    score -= 5;\n    factors.push({\n      type: 'negative',\n      text: 'Brief article may lack comprehensive details'\n    });\n  }\n\n  // 2. Check for statistical references\n  const statsPattern = /\\d+(\\.\\d+)?(%|percent|percentage)/i;\n  if (statsPattern.test(normalizedText)) {\n    score += 7;\n    factors.push({\n      type: 'positive',\n      text: 'Contains statistical information'\n    });\n  }\n\n  // 3. Check for quotes (indicates sourcing)\n  const quotesPattern = /\"([^\"]*)\"/g;\n  const quotes = normalizedText.match(quotesPattern);\n  if (quotes && quotes.length > 0) {\n    score += 8;\n    factors.push({\n      type: 'positive',\n      text: 'Contains direct quotes from sources'\n    });\n  }\n\n  // 4. Check for citation patterns\n  const citationPattern = /(according to|said|reported by|cited|source|study)/i;\n  if (citationPattern.test(normalizedText)) {\n    score += 10;\n    factors.push({\n      type: 'positive',\n      text: 'References external sources or studies'\n    });\n  }\n\n  // 5. Check for sensationalist language\n  const sensationalistWords = /(shocking|unbelievable|mind-blowing|jaw-dropping|you won't believe|incredible|amazing|outrageous|scandal)/i;\n  if (sensationalistWords.test(normalizedText)) {\n    score -= 15;\n    factors.push({\n      type: 'negative',\n      text: 'Contains sensationalist language'\n    });\n  }\n\n  // 6. Check for balanced perspective\n  const balancedPerspectiveWords = /(however|on the other hand|alternatively|in contrast|while|despite|nevertheless|conversely|critics|proponents)/i;\n  if (balancedPerspectiveWords.test(normalizedText)) {\n    score += 8;\n    factors.push({\n      type: 'positive',\n      text: 'Presents multiple perspectives'\n    });\n  }\n\n  // 7. Check for hedging language (indicates scientific caution)\n  const hedgingWords = /(may|might|could|possibly|potentially|suggests|indicates|appears|likely)/i;\n  if (hedgingWords.test(normalizedText)) {\n    score += 5;\n    factors.push({\n      type: 'positive',\n      text: 'Uses appropriately cautious language'\n    });\n  }\n\n  // 8. Check for excessive certainty\n  const certaintyClaims = /(absolutely|definitely|undoubtedly|without question|100 percent|guaranteed|proven fact|irrefutable)/i;\n  if (certaintyClaims.test(normalizedText)) {\n    score -= 8;\n    factors.push({\n      type: 'negative',\n      text: 'Makes claims of absolute certainty'\n    });\n  }\n\n  // 9. General readability check (simple heuristic)\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n  const avgSentenceLength = text.length / Math.max(sentences.length, 1);\n  if (avgSentenceLength > 100) {\n    score -= 5;\n    factors.push({\n      type: 'negative',\n      text: 'Complex sentence structure may obscure meaning'\n    });\n  }\n\n  // 10. Check for academic/technical terms (indicates expertise)\n  const academicTerms = /(methodology|analysis|hypothesis|conclusion|investigation|evidence-based|peer-reviewed|correlation|causation|significant|variable)/i;\n  if (academicTerms.test(normalizedText)) {\n    score += 7;\n    factors.push({\n      type: 'positive',\n      text: 'Uses technical or academic language'\n    });\n  }\n\n  // 11. Check for clickbait title patterns\n  const clickbaitPatterns = /(top \\d+|what happens next|won\\'t believe|changed my life|mind-blowing|trending now|gone wrong)/i;\n  if (clickbaitPatterns.test(normalizedText.substring(0, 500))) {\n    // Check mainly in the beginning\n    score -= 12;\n    factors.push({\n      type: 'negative',\n      text: 'Contains clickbait-style patterns'\n    });\n  }\n\n  // 12. Check for date references (timeliness)\n  const datePatterns = /(january|february|march|april|may|june|july|august|september|october|november|december|yesterday|today|last week|this week)/i;\n  if (datePatterns.test(normalizedText)) {\n    score += 5;\n    factors.push({\n      type: 'positive',\n      text: 'Includes temporal references for context'\n    });\n  }\n\n  // Add neutral information factor\n  factors.push({\n    type: 'neutral',\n    text: 'Analysis uses text patterns to estimate credibility'\n  });\n\n  // Ensure score is within 0-100 range\n  score = Math.max(0, Math.min(100, score));\n  return {\n    score: Math.round(score),\n    factors\n  };\n};","map":{"version":3,"names":["processArticleClientSide","text","summary","summarizeText","credibilityAnalysis","analyzeCredibility","credibilityScore","score","credibilityFactors","factors","sentences","split","filter","sentence","trim","length","wordFreq","stopWords","Set","forEach","words","toLowerCase","word","has","sentenceScores","map","Math","max","sort","a","b","numSentences","min","ceil","topSentences","slice","topIndices","s","findIndex","summarySentences","index","result","join","endsWith","normalizedText","push","type","statsPattern","test","quotesPattern","quotes","match","citationPattern","sensationalistWords","balancedPerspectiveWords","hedgingWords","certaintyClaims","avgSentenceLength","academicTerms","clickbaitPatterns","substring","datePatterns","round"],"sources":["C:/Users/Sulta/Documents/CodingProject/VerifiNews/client/src/utils/clientSummarizer.js"],"sourcesContent":["/**\r\n * Client-side implementation of text summarization and credibility analysis\r\n */\r\n\r\n/**\r\n * Process article text and provide summary and credibility analysis\r\n * @param {string} text - Article text\r\n * @returns {Object} - Result containing summary and credibility analysis\r\n */\r\nexport const processArticleClientSide = (text) => {\r\n    // 1. Summarization\r\n    const summary = summarizeText(text);\r\n    \r\n    // 2. Credibility analysis\r\n    const credibilityAnalysis = analyzeCredibility(text);\r\n    \r\n    return {\r\n      summary,\r\n      credibilityScore: credibilityAnalysis.score,\r\n      credibilityFactors: credibilityAnalysis.factors\r\n    };\r\n  };\r\n  \r\n  /**\r\n   * Text summarization algorithm (extractive approach)\r\n   * @param {string} text - Text to summarize\r\n   * @returns {string} - Summarized text\r\n   */\r\n  export const summarizeText = (text) => {\r\n    // Split text into sentences\r\n    const sentences = text.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0);\r\n    \r\n    if (sentences.length === 0) {\r\n      return \"Unable to summarize. Please provide more content.\";\r\n    }\r\n    \r\n    // Calculate word frequency (simple TF)\r\n    const wordFreq = {};\r\n    const stopWords = new Set([\r\n      'a', 'an', 'the', 'and', 'or', 'but', 'is', 'are', 'was', 'were', \r\n      'be', 'been', 'being', 'in', 'on', 'at', 'to', 'for', 'with', 'by', \r\n      'about', 'as', 'of', 'that', 'this', 'these', 'those', 'it', 'its',\r\n      'they', 'them', 'their', 'there', 'here', 'where', 'when', 'how',\r\n      'has', 'have', 'had', 'not', 'no', 'nor', 'if', 'else', 'then',\r\n      'so', 'than', 'up', 'down', 'out', 'off', 'over', 'under'\r\n    ]);\r\n    \r\n    sentences.forEach(sentence => {\r\n      // Tokenize and clean\r\n      const words = sentence.toLowerCase().split(/\\W+/).filter(word => \r\n        word.length > 1 && !stopWords.has(word)\r\n      );\r\n      \r\n      // Count word frequency\r\n      words.forEach(word => {\r\n        wordFreq[word] = (wordFreq[word] || 0) + 1;\r\n      });\r\n    });\r\n    \r\n    // Score sentences based on word frequency\r\n    const sentenceScores = sentences.map(sentence => {\r\n      const words = sentence.toLowerCase().split(/\\W+/).filter(word => word.length > 1);\r\n      let score = 0;\r\n      \r\n      words.forEach(word => {\r\n        if (wordFreq[word]) {\r\n          score += wordFreq[word];\r\n        }\r\n      });\r\n      \r\n      // Normalize by sentence length (with a minimum to avoid division by zero)\r\n      return {\r\n        text: sentence.trim(),\r\n        score: score / Math.max(words.length, 1)\r\n      };\r\n    });\r\n    \r\n    // Sort sentences by score (descending)\r\n    sentenceScores.sort((a, b) => b.score - a.score);\r\n    \r\n    // Select top sentences (about 25% of the original length, minimum 3, maximum 7)\r\n    const numSentences = Math.min(Math.max(Math.ceil(sentences.length * 0.25), 3), 7);\r\n    \r\n    // Get top sentences\r\n    const topSentences = sentenceScores.slice(0, numSentences);\r\n    \r\n    // Map to original indices\r\n    const topIndices = topSentences.map(s => {\r\n      return sentences.findIndex(sentence => sentence.trim() === s.text);\r\n    });\r\n    \r\n    // Sort by original order\r\n    topIndices.sort((a, b) => a - b);\r\n    \r\n    // Join the selected sentences in their original order\r\n    const summarySentences = topIndices.map(index => sentences[index].trim());\r\n    let result = summarySentences.join('. ');\r\n    \r\n    // Ensure proper ending punctuation\r\n    if (!result.endsWith('.') && !result.endsWith('!') && !result.endsWith('?')) {\r\n      result += '.';\r\n    }\r\n    \r\n    return result;\r\n  };\r\n  \r\n  /**\r\n   * Credibility analysis algorithm\r\n   * @param {string} text - Text to analyze\r\n   * @returns {Object} - Credibility score and factors\r\n   */\r\n  export const analyzeCredibility = (text) => {\r\n    // This is a simplified version that checks for common markers of credibility\r\n    const factors = [];\r\n    let score = 50; // Start with a neutral score\r\n    \r\n    // Normalize text for analysis\r\n    const normalizedText = text.toLowerCase();\r\n    \r\n    // 1. Check text length (longer articles tend to have more depth)\r\n    if (text.length > 3000) {\r\n      score += 5;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Article length indicates depth of coverage'\r\n      });\r\n    } else if (text.length < 1000) {\r\n      score -= 5;\r\n      factors.push({\r\n        type: 'negative',\r\n        text: 'Brief article may lack comprehensive details'\r\n      });\r\n    }\r\n    \r\n    // 2. Check for statistical references\r\n    const statsPattern = /\\d+(\\.\\d+)?(%|percent|percentage)/i;\r\n    if (statsPattern.test(normalizedText)) {\r\n      score += 7;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Contains statistical information'\r\n      });\r\n    }\r\n    \r\n    // 3. Check for quotes (indicates sourcing)\r\n    const quotesPattern = /\"([^\"]*)\"/g;\r\n    const quotes = normalizedText.match(quotesPattern);\r\n    if (quotes && quotes.length > 0) {\r\n      score += 8;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Contains direct quotes from sources'\r\n      });\r\n    }\r\n    \r\n    // 4. Check for citation patterns\r\n    const citationPattern = /(according to|said|reported by|cited|source|study)/i;\r\n    if (citationPattern.test(normalizedText)) {\r\n      score += 10;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'References external sources or studies'\r\n      });\r\n    }\r\n    \r\n    // 5. Check for sensationalist language\r\n    const sensationalistWords = /(shocking|unbelievable|mind-blowing|jaw-dropping|you won't believe|incredible|amazing|outrageous|scandal)/i;\r\n    if (sensationalistWords.test(normalizedText)) {\r\n      score -= 15;\r\n      factors.push({\r\n        type: 'negative',\r\n        text: 'Contains sensationalist language'\r\n      });\r\n    }\r\n    \r\n    // 6. Check for balanced perspective\r\n    const balancedPerspectiveWords = /(however|on the other hand|alternatively|in contrast|while|despite|nevertheless|conversely|critics|proponents)/i;\r\n    if (balancedPerspectiveWords.test(normalizedText)) {\r\n      score += 8;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Presents multiple perspectives'\r\n      });\r\n    }\r\n    \r\n    // 7. Check for hedging language (indicates scientific caution)\r\n    const hedgingWords = /(may|might|could|possibly|potentially|suggests|indicates|appears|likely)/i;\r\n    if (hedgingWords.test(normalizedText)) {\r\n      score += 5;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Uses appropriately cautious language'\r\n      });\r\n    }\r\n    \r\n    // 8. Check for excessive certainty\r\n    const certaintyClaims = /(absolutely|definitely|undoubtedly|without question|100 percent|guaranteed|proven fact|irrefutable)/i;\r\n    if (certaintyClaims.test(normalizedText)) {\r\n      score -= 8;\r\n      factors.push({\r\n        type: 'negative',\r\n        text: 'Makes claims of absolute certainty'\r\n      });\r\n    }\r\n    \r\n    // 9. General readability check (simple heuristic)\r\n    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\r\n    const avgSentenceLength = text.length / Math.max(sentences.length, 1);\r\n    \r\n    if (avgSentenceLength > 100) {\r\n      score -= 5;\r\n      factors.push({\r\n        type: 'negative',\r\n        text: 'Complex sentence structure may obscure meaning'\r\n      });\r\n    }\r\n    \r\n    // 10. Check for academic/technical terms (indicates expertise)\r\n    const academicTerms = /(methodology|analysis|hypothesis|conclusion|investigation|evidence-based|peer-reviewed|correlation|causation|significant|variable)/i;\r\n    if (academicTerms.test(normalizedText)) {\r\n      score += 7;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Uses technical or academic language'\r\n      });\r\n    }\r\n    \r\n    // 11. Check for clickbait title patterns\r\n    const clickbaitPatterns = /(top \\d+|what happens next|won\\'t believe|changed my life|mind-blowing|trending now|gone wrong)/i;\r\n    if (clickbaitPatterns.test(normalizedText.substring(0, 500))) {  // Check mainly in the beginning\r\n      score -= 12;\r\n      factors.push({\r\n        type: 'negative',\r\n        text: 'Contains clickbait-style patterns'\r\n      });\r\n    }\r\n    \r\n    // 12. Check for date references (timeliness)\r\n    const datePatterns = /(january|february|march|april|may|june|july|august|september|october|november|december|yesterday|today|last week|this week)/i;\r\n    if (datePatterns.test(normalizedText)) {\r\n      score += 5;\r\n      factors.push({\r\n        type: 'positive',\r\n        text: 'Includes temporal references for context'\r\n      });\r\n    }\r\n    \r\n    // Add neutral information factor\r\n    factors.push({\r\n      type: 'neutral',\r\n      text: 'Analysis uses text patterns to estimate credibility'\r\n    });\r\n    \r\n    // Ensure score is within 0-100 range\r\n    score = Math.max(0, Math.min(100, score));\r\n    \r\n    return {\r\n      score: Math.round(score),\r\n      factors\r\n    };\r\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}